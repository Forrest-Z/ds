#pragma once

#include <complex>
#include <iterator>

#include "g2o_types/vertex_pose.h"
#include "g2o_types/vertex_timediff.h"

typedef std::vector<VertexPose*> PoseSequence;
typedef std::vector<VertexTimeDiff*> TimeDiffSequence;

class TimedElasticBand
{
public:

  TimedElasticBand();

  virtual ~TimedElasticBand();

  PoseSequence& poses() {return pose_vec_;};
  const PoseSequence& poses() const {return pose_vec_;};
  
  TimeDiffSequence& timediffs() {return timediff_vec_;};
  const TimeDiffSequence& timediffs() const {return timediff_vec_;};  
  
  double& TimeDiff(unsigned int index)
  {
    // ROS_ASSERT(index<sizeTimeDiffs()); 
    return timediff_vec_.at(index)->dt();
  }
  const double& TimeDiff(unsigned int index) const
  {
    // ROS_ASSERT(index<sizeTimeDiffs()); 
    return timediff_vec_.at(index)->dt();
  }
  
  PoseSE2& Pose(unsigned int index) 
  {
    // ROS_ASSERT(index<sizePoses());
    return pose_vec_.at(index)->pose();
  }
  
  const PoseSE2& Pose(unsigned int index) const 
  {
    // ROS_ASSERT(index<sizePoses());
    return pose_vec_.at(index)->pose();
  }
  

  PoseSE2& BackPose() {return pose_vec_.back()->pose(); }
  
  const PoseSE2& BackPose() const {return pose_vec_.back()->pose();}
  
  double& BackTimeDiff() {return timediff_vec_.back()->dt(); }

  const double& BackTimeDiff() const {return timediff_vec_.back()->dt(); }
  
  VertexPose* PoseVertex(unsigned int index) 
  {
    // ROS_ASSERT(index<sizePoses());
    return pose_vec_.at(index);
  }

  VertexTimeDiff* TimeDiffVertex(unsigned int index) 
  {
    // ROS_ASSERT(index<sizeTimeDiffs()); 
    return timediff_vec_.at(index);
  }
  

  void addPose(const PoseSE2& pose, bool fixed=false);  
  void addPose(const Eigen::Ref<const Eigen::Vector2d>& position, double theta, bool fixed=false);
  void addPose(double x, double y, double theta, bool fixed=false);
  
  void addTimeDiff(double dt, bool fixed=false);
  
  void addPoseAndTimeDiff(const PoseSE2& pose, double dt);
  void addPoseAndTimeDiff(const Eigen::Ref<const Eigen::Vector2d>& position, double theta, double dt);
  void addPoseAndTimeDiff(double x, double y, double theta, double dt);
  
  void insertPose(unsigned int index, const PoseSE2& pose);
  void insertPose(unsigned int index, const Eigen::Ref<const Eigen::Vector2d>& position, double theta);
  void insertPose(unsigned int index, double x, double y, double theta);
   
  void insertTimeDiff(unsigned int index, double dt);
    
  void deletePose(unsigned int index);
  void deletePoses(unsigned int index, unsigned int number);

  void deleteTimeDiff(unsigned int index);
  void deleteTimeDiffs(unsigned int index, unsigned int number);
  
  bool initTEBtoGoal(const std::vector<PoseSE2>& plan, double dt, bool estimate_orient, int min_samples);

  void autoResize(double dt_ref, double dt_hysteresis, int min_samples = 3);
  
  void setPoseVertexFixed(unsigned int index, bool status);
  
  void setTimeDiffVertexFixed(unsigned int index, bool status);
  
  void clearTimedElasticBand();
    
  std::size_t sizePoses() const {return pose_vec_.size();};
  
  std::size_t sizeTimeDiffs() const {return timediff_vec_.size();};
  
  bool isInit() const {return !timediff_vec_.empty() && !pose_vec_.empty();}

  double getSumOfAllTimeDiffs() const;
  
  double getAccumulatedDistance() const;
  int findClosestTrajectoryPose(const Eigen::Ref<const Eigen::Vector2d>& ref_point, double* distance = NULL, int begin_idx=0) const;
  
protected:
  PoseSequence pose_vec_; //!< Internal container storing the sequence of optimzable pose vertices
  TimeDiffSequence timediff_vec_;  //!< Internal container storing the sequence of optimzable timediff vertices
  
public:
  EIGEN_MAKE_ALIGNED_OPERATOR_NEW
};
