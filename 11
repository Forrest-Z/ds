
#include <timed_elastic_band.h>

TimedElasticBand::TimedElasticBand()
{		
}

TimedElasticBand::~TimedElasticBand()
{
  clearTimedElasticBand();
}

void TimedElasticBand::addPose(const PoseSE2& pose, bool fixed)
{
  VertexPose* pose_vertex = new VertexPose(pose, fixed);
  pose_vec_.push_back( pose_vertex );
  return;
}

void TimedElasticBand::addPose(const Eigen::Ref<const Eigen::Vector2d>& position, 
                               double theta, bool fixed)
{
  VertexPose* pose_vertex = new VertexPose(position, theta, fixed);
  pose_vec_.push_back( pose_vertex );
  return;
}

void TimedElasticBand::addPose(double x, double y, double theta, bool fixed)
{
  VertexPose* pose_vertex = new VertexPose(x, y, theta, fixed);
  pose_vec_.push_back( pose_vertex );
  return;
}

void TimedElasticBand::addTimeDiff(double dt, bool fixed)
{
  VertexTimeDiff* timediff_vertex = new VertexTimeDiff(dt, fixed);
  timediff_vec_.push_back( timediff_vertex );
  return;
}

void TimedElasticBand::addPoseAndTimeDiff(double x, double y, double angle, double dt)
{
  if (sizePoses() != sizeTimeDiffs())
  {
    addPose(x,y,angle,false);
    addTimeDiff(dt,false);
  }
  else 
  {
    //TODO
  }
  return;
}

void TimedElasticBand::addPoseAndTimeDiff(const PoseSE2& pose, double dt)
{
  if (sizePoses() != sizeTimeDiffs())
  {
    addPose(pose,false);
    addTimeDiff(dt,false);
  } else
  {
    //TODO
  }
  return;
}

void TimedElasticBand::addPoseAndTimeDiff(const Eigen::Ref<const Eigen::Vector2d>& position, 
                                          double theta, double dt)
{
  if (sizePoses() != sizeTimeDiffs())
  {
    addPose(position, theta,false);
    addTimeDiff(dt,false);
  } 
  else 
  {
    //TODO
  }
  return;
}

void TimedElasticBand::deletePose(unsigned int index)
{
  delete pose_vec_.at(index);
  pose_vec_.erase(pose_vec_.begin()+index);
}

void TimedElasticBand::deletePoses(unsigned int index, unsigned int number)
{
	for (unsigned int i = index; i<index+number; ++i)
		delete pose_vec_.at(i);
	pose_vec_.erase(pose_vec_.begin()+index, pose_vec_.begin()+index+number);
}

void TimedElasticBand::deleteTimeDiff(unsigned int index)
{
  delete timediff_vec_.at(index);
  timediff_vec_.erase(timediff_vec_.begin()+index);
}

void TimedElasticBand::deleteTimeDiffs(unsigned int index, unsigned int number)
{
	for (unsigned int i = index; i<index+number; ++i)
		delete timediff_vec_.at(i);
	timediff_vec_.erase(timediff_vec_.begin()+index, timediff_vec_.begin()+index+number);
}

inline void TimedElasticBand::insertPose(unsigned int index, const PoseSE2& pose)
{
  VertexPose* pose_vertex = new VertexPose(pose);
  pose_vec_.insert(pose_vec_.begin()+index, pose_vertex);
}

inline void TimedElasticBand::insertPose(unsigned int index, 
                            const Eigen::Ref<const Eigen::Vector2d>& position, double theta)
{
  VertexPose* pose_vertex = new VertexPose(position, theta);
  pose_vec_.insert(pose_vec_.begin()+index, pose_vertex);
}

inline void TimedElasticBand::insertPose(unsigned int index, double x, double y, double theta)
{
  VertexPose* pose_vertex = new VertexPose(x, y, theta);
  pose_vec_.insert(pose_vec_.begin()+index, pose_vertex);
}

inline void TimedElasticBand::insertTimeDiff(unsigned int index, double dt)
{
  VertexTimeDiff* timediff_vertex = new VertexTimeDiff(dt);
  timediff_vec_.insert(timediff_vec_.begin()+index, timediff_vertex);
}

void TimedElasticBand::clearTimedElasticBand()
{
  for (PoseSequence::iterator pose_it = pose_vec_.begin(); pose_it != pose_vec_.end(); ++pose_it)
    delete *pose_it;
  pose_vec_.clear();
  
  for (TimeDiffSequence::iterator dt_it = timediff_vec_.begin(); dt_it != timediff_vec_.end(); ++dt_it)
    delete *dt_it;
  timediff_vec_.clear();
}

void TimedElasticBand::setPoseVertexFixed(unsigned int index, bool status)
{
  pose_vec_.at(index)->setFixed(status);   
}

void TimedElasticBand::setTimeDiffVertexFixed(unsigned int index, bool status)
{
  timediff_vec_.at(index)->setFixed(status);
}

void TimedElasticBand::autoResize(double dt_ref, double dt_hysteresis, int min_samples)
{
  /// iterate through all TEB states only once and add/remove states!
  for(unsigned int i=0; i < sizeTimeDiffs(); ++i) // TimeDiff connects Point(i) with Point(i+1)
  {
    if(TimeDiff(i) > dt_ref + dt_hysteresis)
    {      
      double newtime = 0.5*TimeDiff(i);

      TimeDiff(i) = newtime;
      insertPose(i+1, PoseSE2::average(Pose(i),Pose(i+1)) );
      insertTimeDiff(i+1,newtime);
      
      ++i; // skip the newly inserted pose
    }
    else if(TimeDiff(i) < dt_ref - dt_hysteresis && (int)sizeTimeDiffs()>min_samples) // only remove samples if size is larger than min_samples.
    {      
      if(i < (sizeTimeDiffs()-1))
      {
        TimeDiff(i+1) = TimeDiff(i+1) + TimeDiff(i);
        deleteTimeDiff(i);
        deletePose(i+1);
      }
    }
  }

  // for(unsigned int i=1; i < pose_vec_.size(); ++i) // TimeDiff connects Point(i) with Point(i+1)
  // {
  //   double x = pose_vec_[i]->pose().x() - pose_vec_[i-1]->pose().x();
  //   double y = pose_vec_[i]->pose().y() - pose_vec_[i-1]->pose().y();
  //   double tempDet = x*x + y*y;
  //   if(tempDet > 0.09)
  //   {      
  //     double newtime = 0.5*TimeDiff(i-1);

  //     TimeDiff(i) = newtime;
  //     insertPose(i, PoseSE2::average(Pose(i-1),Pose(i)) );
  //     insertTimeDiff(i,newtime);
      
  //     ++i; // skip the newly inserted pose
  //   }
  //   else if(TimeDiff(i) < dt_ref - dt_hysteresis && (int)sizeTimeDiffs()>min_samples) // only remove samples if size is larger than min_samples.
  //   {      
  //     if(i < (sizeTimeDiffs()-1))
  //     {
  //       TimeDiff(i+1) = TimeDiff(i+1) + TimeDiff(i);
  //       deleteTimeDiff(i);
  //       deletePose(i+1);
  //     }
  //   }
  // }
}

double TimedElasticBand::getSumOfAllTimeDiffs() const
{
  double time = 0;

  for(TimeDiffSequence::const_iterator dt_it = timediff_vec_.begin(); dt_it != timediff_vec_.end(); ++dt_it)
  {
      time += (*dt_it)->dt();
  }
  return time;
}

double TimedElasticBand::getAccumulatedDistance() const
{
  double dist = 0;

  for(std::size_t i=1; i<sizePoses(); ++i)
  {
      dist += (Pose(i).position() - Pose(i-1).position()).norm();
  }
  return dist;
}

bool TimedElasticBand::initTEBtoGoal(const std::vector<PoseSE2>& plan, double dt, bool estimate_orient, int min_samples)
{
  
  if (!isInit())
  { 
    addPose(plan.front()); // add starting point with given orientation
    setPoseVertexFixed(0,true); // StartConf is a fixed constraint during optimization
   
    for (unsigned int i=1; i<plan.size()-1; ++i)
    {
        double yaw;
        if (estimate_orient)
        {
            // get yaw from the orientation of the distance vector between pose_{i+1} and pose_{i}
            double dx = plan[i+1].x() - plan[i].x();
            double dy = plan[i+1].y() - plan[i].y();
            yaw = std::atan2(dy,dx);
        }
        else 
        {
            yaw = plan[i].theta();
        }
        addPoseAndTimeDiff(plan[i], dt);
    }
    
    PoseSE2 goal(plan.back());
    
    // if number of samples is not larger than min_samples, insert manually
    if ( (int)sizePoses() < min_samples-1 )
    {
      // ROS_DEBUG("initTEBtoGoal(): number of generated samples is less than specified by min_samples. Forcing the insertion of more samples...");
      while ((int)sizePoses() < min_samples-1) // subtract goal point that will be added later
      {
        // simple strategy: interpolate between the current pose and the goal
        addPoseAndTimeDiff( PoseSE2::average(BackPose(), goal), dt ); // let the optimier correct the timestep (TODO: better initialization 
      }
    }
    
    // Now add final state with given orientation
    addPoseAndTimeDiff(goal, dt);
    setPoseVertexFixed(sizePoses()-1,true); // GoalConf is a fixed constraint during optimization
  }
  else // size!=0
  {
    // ROS_WARN("Cannot init TEB between given configuration and goal, because TEB vectors are not empty or TEB is already initialized (call this function before adding states yourself)!");
    // ROS_WARN("Number of TEB configurations: %d, Number of TEB timediffs: %d",(unsigned int) sizePoses(),(unsigned int) sizeTimeDiffs());
    return false;
  }
  
  return true;
}

int TimedElasticBand::findClosestTrajectoryPose(const Eigen::Ref<const Eigen::Vector2d>& ref_point, double* distance, int begin_idx) const
{
  std::vector<double> dist_vec; // TODO: improve! efficiency
  dist_vec.reserve(sizePoses());
  
  int n = sizePoses();
  
  // calc distances
  for (int i = begin_idx; i < n; i++)
  {
    Eigen::Vector2d diff = ref_point - Pose(i).position();
    dist_vec.push_back(diff.norm());
  }
  
  if (dist_vec.empty())
    return -1;
  
  // find minimum
  int index_min = 0;

  double last_value = dist_vec.at(0);
  for (int i=1; i < (int)dist_vec.size(); i++)
  {
    if (dist_vec.at(i) < last_value)
    {
      last_value = dist_vec.at(i);
      index_min = i;
    }
  }
  if (distance)
    *distance = last_value;
  return begin_idx+index_min;
}
