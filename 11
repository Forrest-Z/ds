
#pragma once

#include "g2o/stuff/misc.h"
#include <Eigen/Core>
#include "misc.h"

class PoseSE2
{
public:
  PoseSE2()
  {
    setZero();
  }      
  PoseSE2(const Eigen::Ref<const Eigen::Vector2d>& position, double theta)
  {
      _position = position;
      _theta = theta;
  }
  
  PoseSE2(double x, double y, double theta)
  {
      _position.coeffRef(0) = x;
      _position.coeffRef(1) = y;
      _theta = theta;
  }
  
  PoseSE2(const PoseSE2& pose)
  {
      _position = pose._position;
      _theta = pose._theta;
  }
	
  ~PoseSE2() {}

  Eigen::Vector2d& position() {return _position;}

  const Eigen::Vector2d& position() const {return _position;}
  
  double& x() {return _position.coeffRef(0);}
  
  const double& x() const {return _position.coeffRef(0);}
  
  double& y() {return _position.coeffRef(1);}
  
  const double& y() const {return _position.coeffRef(1);}
  
  double& theta() {return _theta;}
  
  const double& theta() const {return _theta;}
  
  void setZero()
  {
    _position.setZero();
    _theta = 0;
  }
  
  /**
   * @brief Return the unit vector of the current orientation
   * @returns [cos(theta), sin(theta))]^T
   */  
  Eigen::Vector2d orientationUnitVec() const {return Eigen::Vector2d(std::cos(_theta), std::sin(_theta));}
      
  ///@}

      
  /** @name Arithmetic operations for which operators are not always reasonable */
  ///@{ 
  
  /**
    * @brief Scale all SE2 components (x,y,theta) and normalize theta afterwards to [-pi, pi]
    * @param factor scale factor
    */ 
  void scale(double factor)
  {
    _position *= factor;
    _theta = g2o::normalize_theta( _theta*factor );
  }
	  
  /**
    * @brief Increment the pose by adding a double[3] array
    * The angle is normalized afterwards
    * @param pose_as_array 3D double array [x, y, theta]
    */ 
  void plus(const double* pose_as_array)
  {
    _position.coeffRef(0) += pose_as_array[0];
    _position.coeffRef(1) += pose_as_array[1];
    _theta = g2o::normalize_theta( _theta + pose_as_array[2] );
  }
  
  /**
    * @brief Get the mean / average of two poses and store it in the caller class
    * For the position part: 0.5*(x1+x2)
    * For the angle: take the angle of the mean direction vector
    * @param pose1 first pose to consider
    * @param pose2 second pose to consider
    */ 
  void averageInPlace(const PoseSE2& pose1, const PoseSE2& pose2)
  {
    _position = (pose1._position + pose2._position)/2;
    _theta = g2o::average_angle(pose1._theta, pose2._theta);
  }
  
  /**
    * @brief Get the mean / average of two poses and return the result (static)
    * For the position part: 0.5*(x1+x2)
    * For the angle: take the angle of the mean direction vector
    * @param pose1 first pose to consider
    * @param pose2 second pose to consider
    * @return mean / average of \c pose1 and \c pose2
    */ 
  static PoseSE2 average(const PoseSE2& pose1, const PoseSE2& pose2)
  {
    return PoseSE2( (pose1._position + pose2._position)/2 , g2o::average_angle(pose1._theta, pose2._theta) );
  }
  
  PoseSE2& operator=( const PoseSE2& rhs ) 
  {
    if (&rhs != this)
    {
    	_position = rhs._position;
    	_theta = rhs._theta;
    }
    return *this;
  }

  PoseSE2& operator+=(const PoseSE2& rhs)
  {
    _position += rhs._position;
    _theta = g2o::normalize_theta(_theta + rhs._theta);
    return *this;
  }
  
  friend PoseSE2 operator+(PoseSE2 lhs, const PoseSE2& rhs) 
  {
    return lhs += rhs;
  }
  
  PoseSE2& operator-=(const PoseSE2& rhs)
  {
    _position -= rhs._position;
    _theta = g2o::normalize_theta(_theta - rhs._theta);
    return *this;
  }
  
  friend PoseSE2 operator-(PoseSE2 lhs, const PoseSE2& rhs) 
  {
    return lhs -= rhs;
  }
  
  friend PoseSE2 operator*(PoseSE2 pose, double scalar) 
  {
    pose._position *= scalar;
    pose._theta *= scalar;
    return pose;
  }
  
  friend PoseSE2 operator*(double scalar, PoseSE2 pose) 
  {
    pose._position *= scalar;
    pose._theta *= scalar;
    return pose;
  }
  
	friend std::ostream& operator<< (std::ostream& stream, const PoseSE2& pose)
	{
		stream << "x: " << pose._position[0] << " y: " << pose._position[1] << " theta: " << pose._theta;
    return stream;
	}
      
private:
  
  Eigen::Vector2d _position; 
  double _theta;
      
public:
  EIGEN_MAKE_ALIGNED_OPERATOR_NEW  
};
