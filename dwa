1 文档介绍
本文档是介绍DWA算法的算法说明文档。
1.1 文档目的
本文档主要介绍了DWA算法的算法原理以及在此基础上的改进,并分析了该算法的优缺点。
1.2 读者对象
本文档预期读者对象为：
1) 算法开发人员;
2) 感兴趣人员

2 算法说明
从各个模块对DWA算法进行了描述说明.
2.1 算法背景介绍
在无人车的各个模块中,路径规划直接关系到走怎么样以及走的好不好的路的问题,是横纵向控制的直接上层输入.传统的应用在轮式机器人上面的路径规划,早在20世纪七十年代就已经有了长足的发展,包括A*, PRM, 人工势场, RRT等方法.但是一般这种轮式机器人都是用的差速轮,所以转向相对ackerman的车辆来说转向灵活很多.并且室内机器人的速度一般较低,制动灵活性也比较高,对于规划的要求没这么严格.
后来的研究针对ackerman类型的车辆模型进行了优化,如dwa, hybrid a*以及rrt的一些变种等,将车辆的几何模型融入到避障算法当中.也有很多考虑车辆运动学模型的规划方法,生成的路径不仅能够保证安全的需求并且能最大程度满足车辆的执行特性.本文的算法就是考虑车辆的几何以及运动学模型的一种运动规划方法.
2.2 算法原理详述
动态窗口法(dynamic window approach),简称DWA,基本的算法描述如下:
主要实在速度(v, w)空间中采样多组速度,并模拟车辆在这些速度下一定时间(sim_period)内的轨迹.在得到多组轨迹以后,对这些轨迹进行评价,选取最优轨迹所对应的速度来驱动机器人运动.该算法突出点在于动态窗口这个名词,它的含义是依据移动机器人的加减速性能限定速度采样空间在一个可行的动态范围内.
1) 首先需考虑机器人的运动模型
假设车辆的轨迹是一段一段的圆弧或者直线组成的(变曲率的轨迹实际上也是一段一段变半径的圆弧组成的).
2) 对速度进行采样(线速度, 角速度)
速度采样受车辆本身的限制以及环境限制,因此速度空间可以控制在一定的范围内:
a) 车辆受自身最大速度最小速度的限制；
b) 车辆受电机性能的影响:电机力矩有限,存在最大加减速限制；
c) 基于车辆安全性的考虑.
3) 根据评价函数对轨迹进行评价
i. 方位角评价,即与目标之间的角度差距；
ii. 安全距离,即与最近的障碍物之间的距离；
iii. 速度,即当前轨迹与期望速度的偏差；
iv. 需要对各个评价指标进行平滑处理,即归一化.
       这样构成的评价函数的物理意义是:在导航过程中,使得机器人避开障碍物,朝着目标区域以较快的速度行驶.
2.3 算法流程分析
本文作者介绍的算法在传统的dwa算法上进行了一系列的优化改进,融入A*贪婪式图搜索的框架,并且用Dubins以及Reeds-Shepp曲线作为搜索的距离引导启发,以及一些独特的处理,兼顾了算法的完备性以及效率,能够较好的满足车辆的几何模型以及运动学,动力学特性,从而能让横纵向更协调的控制.
算法的整体流程如下所示:
Algorithm: dwaplanner.cpp
1: void dwaplanner::obstaclemodify(ivpredict::ivmsgpredict 	2: objs, sorted_tree &nearestobs, sorted_tree &rawobs, 	
3: sorted_tree &dilatedobs, float carspeed);
4: ivpathplanner::path 	
5: dwaplanner::pathinterface(ivmap::ivmapmsglocpos 	
6: ivlocpos, ivpathplanner::path current, ivpathplanner::path 
7: rawpath, sorted_tree sortedobjs);
Obstaclemodify 用于对传入的障碍物进行处理,比如分为最近的障碍物,原始的障碍物,膨胀的障碍物等；
Algorithm: obstaclemodify
1. 清空各sorted_tree类型的存储;
2. 构造自车大小的carmodel;
3. for cell in objects:
4. If (距离 < 12):
5. Continue;
6. Else:
7. If (距离 < 4)
8. 存到最近的障碍物类型中；
9. If (障碍物类型是动态)
10. Continue；
11. 存入原始的障碍物类型中；
12. 长宽膨胀处理,存入膨胀之后的障碍物类型中.
13. Return;

Algorithm: pathinterface
1.  如果没有障碍物,return当前路径；
2.  将路点1m每段存Id号；
3.  路长小于12m,不避障；
4.  将大于12m的路段部分再分为4段,取4个终点；
5.  选取每个终点规划避障路线；
6.  避障成功,则退出;
7.  如果一直处理知道终点序列都不可行,避障失败

核心避障算法如下所示:
Algorithm: dynamicWindowApproach
1. 初始化优先级队列的open表:frontier, 表示节点之间关系的multimap:came_from,以及存储到当前节点的cost: cost_so_far；
2. While open表非空:
3. 弹出优先级最高的节点;
4. 判断当前节点对应生成的状态序列是否碰撞,如果碰撞,continue；
否则,进行下一步；
5. 如果到达目的地,退出；否则,进行下一步；
6. GenerateTrajectory:以当前状态为初始状态,对速度(控制量)采样,生成新的状态序列；
7. 新的状态序列末尾状态对应Dubins曲线算出距离启发值,及A*的h值,并且本身具有实际距离权重g值；
8. 如果新的末尾状态不再close表中,若也不在open表中或者新的权值比之前open表中的权值大,更新close表和open表；

该核心避障算法以A*为搜索的基本框架,以Dubins或者Reeds-Shepp曲线为距离启发函数,状态之间的转移以运动学方程建立,所以能够得到满足运动学非完整约束的规划路径；
然后,在close表中,reconstructPath逆序查找生成避障路径.

2.4 算法特性以及优缺点分析
该算法基本能满足小车的避障性能需求以及效率需求,由于是基于模型生成的避障路径,所以对于控制来说也比较友好,但是也存在以下几个主要问题:
1) 对空间的利用率不高,在避让大型障碍物时尤其明显,贴着障碍物行驶,对控制的精度要求提高；
2) 在线轨迹实时生成会对效率产生一定的影响；
3) 基于贪婪式搜索,多数情况下拟人化做的不好.
后期考虑生成路径的二次优化,保障曲率连续性,路径点加速度,速度的连续性等等优化指标

3 附录
Dwa: http://blog.csdn.net/heyijia0327/article/details/44983551

Dubins: http://blog.csdn.net/robinvista/article/details/54141762

A*: http://www.sbpl.net/


